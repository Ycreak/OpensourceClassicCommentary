<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>open-source-classic-commentary documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>

        <div class="navbar navbar-default navbar-fixed-top visible-xs">
            <a href="../" class="navbar-brand">open-source-classic-commentary documentation</a>
            <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="hidden-xs menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li>Interfaces</li>
  <li
  >
  UserData</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="active">
            <a href="#info" role="tab" id="info-tab" data-toggle="tab" data-link="info">Info</a>
        </li>
        <li >
            <a href="#source" role="tab" id="source-tab" data-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="c-info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/dashboard/dashboard.component.ts</code>
        </p>




        <section>
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#role" 
>
                                            role
                                        </a>
                                </li>
                                <li>
                                        <a href="#username" 
>
                                            username
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section>
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="role"></a>
                                        <span class="name "><b>role</b>
                                            <a href="#role">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>role:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="username"></a>
                                        <span class="name "><b>username</b>
                                            <a href="#username">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>username:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="c-source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Component, OnInit} from &#x27;@angular/core&#x27;;
import { AfterViewInit, ViewChild } from &#x27;@angular/core&#x27;;
import {Observable} from &#x27;rxjs&#x27;;
import {map, startWith} from &#x27;rxjs/operators&#x27;;
import { FormBuilder } from &#x27;@angular/forms&#x27;;
import { ReactiveFormsModule, FormControl, FormGroup, Validators, FormArray } from &#x27;@angular/forms&#x27;;
import { MatTabChangeEvent } from &#x27;@angular/material/tabs&#x27;;
import { MatDialog, MatDialogRef, MAT_DIALOG_DATA } from &#x27;@angular/material/dialog&#x27;;
import {MatPaginator} from &#x27;@angular/material/paginator&#x27;;
import {MatSort} from &#x27;@angular/material/sort&#x27;;
import {MatTableDataSource} from &#x27;@angular/material/table&#x27;;

// Component imports
import { ApiService } from &#x27;../api.service&#x27;;
import { UtilityService } from &#x27;../utility.service&#x27;;
import { AuthService } from &#x27;../auth/auth.service&#x27;;
import { DialogService } from &#x27;../services/dialog.service&#x27;;

// Model imports 
import { Fragment } from &#x27;../models/Fragment&#x27;;

// Third party imports
import insertTextAtCursor from &#x27;insert-text-at-cursor&#x27;;
import { IKeyboardLayouts, keyboardLayouts, MAT_KEYBOARD_LAYOUTS, MatKeyboardModule } from &#x27;angular-onscreen-material-keyboard&#x27;;
// To install the onscreen keyboard: $ npm i angular-onscreen-material-keyboard

export interface UserData {
  username: string;
  role: string;
}

@Component({
  selector: &#x27;app-dashboard&#x27;,
  templateUrl: &#x27;./dashboard.component.html&#x27;,
  styleUrls: [&#x27;./dashboard.component.scss&#x27;]
})
export class DashboardComponent implements OnInit {

  
  @ViewChild(MatPaginator) paginator: MatPaginator;
  @ViewChild(MatSort) sort: MatSort;
  
  displayedColumns: string[] &#x3D; [&#x27;username&#x27;, &#x27;role&#x27;]; //[&#x27;id&#x27;, &#x27;name&#x27;, &#x27;progress&#x27;, &#x27;fruit&#x27;];
  dataSource: MatTableDataSource&lt;UserData&gt;;

  selected_author: string &#x3D; &#x27;&#x27;;
  selected_book: string &#x3D; &#x27;&#x27;;
  selected_editor: string &#x3D; &#x27;&#x27;;
  selected_fragment : string;

  retrieved_authors: object;
  retrieved_books: object;
  retrieved_editors: object;

  retrieved_fragment: Fragment;
  retrieved_fragments: object;
  retrieved_fragment_numbers: object;

  retrieved_bibliography_authors: object;
  retrieved_author_bibliography: object;

  // Forms
  fragmentForm: FormGroup &#x3D; this.formBuilder.group({
    _id: &#x27;&#x27;,
    fragment_name: &#x27;&#x27;, //[&#x27;&#x27;, Validators.required],
    author: &#x27;&#x27;,
    title: &#x27;&#x27;,
    editor: &#x27;&#x27;,
    translation: &#x27;&#x27;,
    differences: &#x27;&#x27;,
    commentary: &#x27;&#x27;,
    apparatus: &#x27;&#x27;,
    reconstruction: &#x27;&#x27;,
    context: this.formBuilder.array([ ]),
    lines: this.formBuilder.array([ ]),
    linked_fragments: this.formBuilder.array([ ]),
    linked_bib_entries: this.formBuilder.array([ ]),
    status: &#x27;&#x27;,
    lock: 0,
  });

  bibliography_form : FormGroup &#x3D; this.formBuilder.group({
    _id: &#x27;&#x27;,
    bib_entry_type: &#x27;book&#x27;, // Book is default on page load
    author: &#x27;&#x27;,
    title: &#x27;&#x27;,
    year: &#x27;&#x27;,
    series: &#x27;&#x27;,
    number: &#x27;&#x27;,
    location: &#x27;&#x27;,
    edition: &#x27;&#x27;,
    journal: &#x27;&#x27;,
    volume: &#x27;&#x27;,
    pages: &#x27;&#x27;,
  });

  pointer_editor : string;

  spinner_active : boolean &#x3D; false;

  // User dashboard
  isChecked &#x3D; false;
  temp &#x3D; &#x27;&#x27;
  hide : boolean &#x3D; true;
  change_password_form &#x3D; this.formBuilder.group({
    password1: &#x27;&#x27;,
    password2: &#x27;&#x27;,
  });

  retrieved_users : UserData[]; 
  selected_user : string &#x3D; &#x27;&#x27;;
  user_selected : boolean &#x3D; false; // controls user deletion button
  new_user : string &#x3D; &#x27;&#x27;;
  new_user_password : string &#x3D; &#x27;&#x27;;

  // Whether a fragment is selected
  fragment_selected : boolean &#x3D; false;
  allow_fragment_creation &#x3D; false;

  // Bibliography author selection
  bibliography_author_selection_form &#x3D; new FormControl();
  bibliography_author_selection_form_options: string[] &#x3D; [];
  bibliography_author_selection_form_filtered_options: Observable&lt;string[]&gt;;
  bibliography_form_selected_type &#x3D; new FormControl(0);
  bib_entry_selected : boolean &#x3D; false;

  constructor(
    private api: ApiService,
    private utility: UtilityService,
    public dialog: DialogService,
    private formBuilder: FormBuilder,
    public authService: AuthService,
    ) {

    // Assign the data to the data source for the table to render
    this.dataSource &#x3D; new MatTableDataSource(this.retrieved_users);
    }

    public ngAfterViewInit() {
      this.dataSource.paginator &#x3D; this.paginator;
      this.dataSource.sort &#x3D; this.sort;
    }

    public applyFilter(event: Event) {
      const filterValue &#x3D; (event.target as HTMLInputElement).value;
      this.dataSource.filter &#x3D; filterValue.trim().toLowerCase();
  
      if (this.dataSource.paginator) {
        this.dataSource.paginator.firstPage();
      }
    }

  /**
   * On Init, we just load the list of authors. From here, selection is started
   */
  ngOnInit(): void {
    this.RequestAuthors()
    this.Request_users()
    // this.request_bibliography_authors()

    // this.bibliography_author_selection_form_filtered_options &#x3D; this.bibliography_author_selection_form.valueChanges.pipe(
    //   startWith(&#x27;&#x27;),
    //   map(value &#x3D;&gt; this.filter_autocomplete_options(value)),
    // );
  }


  /**
   * Simple test function, can be used for whatever
   * @param thing item to be printed
   */
  public Test(thing){
    console.log(this.retrieved_users)

    // console.log(this.bibliography_author_selection_form_options)
    // console.log(this.retrieved_fragment)
    
    // let current_fragment &#x3D; new Fragment({});

    // current_fragment.author &#x3D; &#x27;Ennius&#x27;
    // current_fragment.title &#x3D; &#x27;Thyestes&#x27;

    // console.log(current_fragment)

    // this.Request_automatic_fragment_linker(current_fragment)


  }

  // /** Builds and returns a new User. */
  // public createNewUser(id: number): UserData {
  //   const name &#x3D;
  //     NAMES[Math.round(Math.random() * (NAMES.length - 1))] +
  //     &#x27; &#x27; +
  //     NAMES[Math.round(Math.random() * (NAMES.length - 1))].charAt(0) +
  //     &#x27;.&#x27;;

  //   return {
  //     id: id.toString(),
  //     name: name,
  //     progress: Math.round(Math.random() * 100).toString(),
  //     fruit: FRUITS[Math.round(Math.random() * (FRUITS.length - 1))],
  //   };
  // }

  public Retrieve_fragment_numbers(fragments){    
    let number_list &#x3D; []

    for(let fragment in fragments){
      number_list.push(fragments[fragment].fragment_name)
    }
    // Sort the list and return it
    number_list.sort(this.utility.SortNumeric);

    return number_list
  }

  public Retrieve_requested_fragment(fragments, fragment_number){
    let fragment_id &#x3D; &#x27;&#x27;

    for(let fragment in fragments){
      if(fragments[fragment].fragment_name &#x3D;&#x3D; fragment_number){
        fragment_id &#x3D; fragments[fragment].id
      }
    }
    // Now, get this fragment from the server
    this.api.get_specific_fragment(fragment_id).subscribe(
      data &#x3D;&gt; { 
        this.retrieved_fragment &#x3D; data;
        this.selected_fragment &#x3D; fragment_number;
        this.Update_content_form(this.retrieved_fragment);

    });
  }

  public Clean_fragment_content(){
    // Clears context and lines
    this.Clear_fields()

    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;translation&#x27;, &#x27;&#x27;);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;differences&#x27;, &#x27;&#x27;);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;commentary&#x27;, &#x27;&#x27;);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;apparatus&#x27;, &#x27;&#x27;);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;reconstruction&#x27;, &#x27;&#x27;);
  }

  public Update_content_form(fragment){
    // This functions updates the fragmentForm with the provided fragment
    // FIXME: This should be done using a for loop
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;_id&#x27;, fragment.id);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;fragment_name&#x27;, fragment.fragment_name);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;author&#x27;, fragment.author);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;title&#x27;, fragment.title);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;editor&#x27;, fragment.editor);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;translation&#x27;, fragment.translation);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;differences&#x27;, fragment.differences);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;commentary&#x27;, fragment.commentary);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;apparatus&#x27;, fragment.apparatus);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;reconstruction&#x27;, fragment.reconstruction);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;status&#x27;, fragment.status);
    this.UpdateForm(&#x27;fragmentForm&#x27;,&#x27;lock&#x27;, fragment.lock);

  

    // Fill the fragment context array
    for (let item in fragment.context){
      let items &#x3D; this.fragmentForm.get(&#x27;context&#x27;) as FormArray;
      items.push(
        this.formBuilder.group({
          author: fragment.context[item].author,
          location: fragment.context[item].location,
          text: fragment.context[item].text,
        })
      );
    }
    // Fill the fragment lines array
    for (let item in fragment.lines){
      let items &#x3D; this.fragmentForm.get(&#x27;lines&#x27;) as FormArray;
      items.push(
        this.formBuilder.group({
          &#x27;line_number&#x27;: fragment.lines[item].line_number,
          &#x27;text&#x27;: fragment.lines[item].text,
        })
      );
    }
    // Fill the linked fragment array
    for (let item in fragment.linked_fragments){
      let items &#x3D; this.fragmentForm.get(&#x27;linked_fragments&#x27;) as FormArray;
      items.push(
        this.formBuilder.group({
          fragment_id: fragment.linked_fragments[item],
        })
      );
    }

    for (let item in fragment.linked_bib_entries){

      // Request additional data from this item
      this.request_bibliography_from_id(fragment.linked_bib_entries[item])

      let items &#x3D; this.fragmentForm.get(&#x27;linked_bib_entries&#x27;) as FormArray;
      items.push(
        this.formBuilder.group({
          bib_id: fragment.linked_bib_entries[item],
          author: &#x27;&#x27;,
          title: &#x27;&#x27;,
          year: &#x27;&#x27;,
        })
      );
    }
  }

////////////////////////////////////////////////////////////////////////////

  public Push_fragment_line(line_number, text){
    let fragment_lines &#x3D; this.fragmentForm.get(&#x27;lines&#x27;) as FormArray;
    fragment_lines.push(
      this.formBuilder.group({
        line_number: line_number,
        text: text,
      })
    );
  }

  public Push_fragment_context(author, location, text){
    let fragment_context &#x3D; this.fragmentForm.get(&#x27;context&#x27;) as FormArray;
    fragment_context.push(
      this.formBuilder.group({
        author: author,
        location: location,
        text: text,
      })
    );
  }

  public push_bibliography_reference(bib_entry){
    let bibliography_references &#x3D; this.fragmentForm.get(&#x27;linked_bib_entries&#x27;) as FormArray;
    bibliography_references.push(
      this.formBuilder.group({
        bib_id: bib_entry._id,
        author: bib_entry.author,
        title: bib_entry.title,
        year: bib_entry.year,
      })
    );
  }

  // DEPRECATED
  // public Push_fragment_link(author, title, editor ,fragment_name, fragment_id){
  //   let fragment_link &#x3D; this.fragmentForm.get(&#x27;linked_fragments&#x27;) as FormArray;
  //   fragment_link.push(
  //     this.formBuilder.group({
  //       author: author,
  //       title: title,
  //       editor: editor,
  //       fragment_name: fragment_name,
  //       fragment_id: fragment_id,
  //     })
  //   );    
  // }  
  // FORM RELATED FUNCTIONS
  /**
   * Updates a value of a key in the given form
   * @param form what form is to be updated
   * @param key what field is to be updated
   * @param value what value is to be written
   */
  public UpdateForm(form, key, value) {
    this[form].patchValue({[key]: value});
  }

  public Reset_form(){
    this.fragmentForm.reset();
    this.bibliography_form.reset();
    this.Clear_fields();
  }

  public Clear_fields(){
    let context &#x3D; this.fragmentForm.get(&#x27;context&#x27;) as FormArray
    let lines &#x3D; this.fragmentForm.get(&#x27;lines&#x27;) as FormArray
    let linked_fragments &#x3D; this.fragmentForm.get(&#x27;linked_fragments&#x27;) as FormArray
    let linked_bib_entries &#x3D; this.fragmentForm.get(&#x27;linked_bib_entries&#x27;) as FormArray

    context.clear()
    lines.clear()
    linked_fragments.clear()
    linked_bib_entries.clear()
  }


  public Remove_form_item(target: string, index: number) {
    let items &#x3D; this.fragmentForm.get(target) as FormArray;
    items.removeAt(index);
  }

  // public Request_fragment_lock(form){
    
  //   let lock_status &#x3D; (form.lock ? 1 : 0);
        
  //   this.api.update_fragment_lock({&#x27;id&#x27;: form._id, &#x27;lock&#x27;: lock_status}).subscribe(
  //     res &#x3D;&gt; this.utility.handle_error_message(res), err &#x3D;&gt; this.utility.handle_error_message(err)
  //   );  
  // }

//   _____  ______ ____  _    _ ______  _____ _______ _____ 
//  |  __ \|  ____/ __ \| |  | |  ____|/ ____|__   __/ ____|
//  | |__) | |__ | |  | | |  | | |__  | (___    | | | (___  
//  |  _  /|  __|| |  | | |  | |  __|  \___ \   | |  \___ \ 
//  | | \ \| |___| |__| | |__| | |____ ____) |  | |  ____) |
//  |_|  \_\______\___\_\\____/|______|_____/   |_| |_____/                                                    

  /**
   * Requests all authors from the database. No parameters needed
   */
  public RequestAuthors(){
    this.api.get_authors().subscribe(
      data &#x3D;&gt; this.retrieved_authors &#x3D; data,
      err &#x3D;&gt; this.utility.handle_error_message(err),
    );      
  }

  public RequestBooks(author: string){
    this.api.get_titles(author).subscribe(
      data &#x3D;&gt; {
        this.retrieved_books &#x3D; data;
      }
    );      
  }

  public RequestEditors(author: string, book: string){
    this.api.get_editors(author, book).subscribe(
      data &#x3D;&gt; {
        this.retrieved_editors &#x3D; data;
      }
    );
  }

  public Request_fragments(author: string, book: string, editor: string){
    this.api.get_fragments(author, book, editor).subscribe(
      data &#x3D;&gt; { 
        this.retrieved_fragments &#x3D; data;
        this.retrieved_fragment_numbers &#x3D; this.Retrieve_fragment_numbers(data);
      });  
  }

  public Request_revise_fragment(fragment){
    // If the fragment is locked and the user is not a teacher, we will not allow this operation.
        
    if(fragment.lock &amp;&amp; !this.authService.is_teacher){
      this.utility.open_snackbar(&#x27;This fragment is locked.&#x27;)
    }
    else{
      let item_string &#x3D; fragment.author + &#x27;, &#x27; +  fragment.title + &#x27;, &#x27; + fragment.editor + &#x27;: &#x27; + fragment.fragment_name

      this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to REVISE this fragment?&#x27;, item_string).subscribe(result &#x3D;&gt; {
        if(result){
          this.api.revise_fragment(fragment).subscribe(
            res &#x3D;&gt; {
              this.utility.handle_error_message(res);
            }, 
            err &#x3D;&gt; this.utility.handle_error_message(err)
          );
        }
      });
      this.Reset_form();
    }
  }

  public Request_create_fragment(fragment){
    let item_string &#x3D; fragment.author + &#x27;, &#x27; +  fragment.title + &#x27;, &#x27; + fragment.editor + &#x27;: &#x27; + fragment.fragment_name

    this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to CREATE this fragment?&#x27;, item_string).subscribe(result &#x3D;&gt; {
      if(result){
        this.api.create_fragment(fragment).subscribe(
          res &#x3D;&gt; this.utility.handle_error_message(res), err &#x3D;&gt; this.utility.handle_error_message(err)
        );
      }
    });
    // Now reset form and request the fragments again
    this.Reset_form();
    this.Request_fragments(this.selected_author, this.selected_book, this.selected_editor);
  }

  public Request_delete_fragment(fragment){
    let item_string &#x3D; fragment.author + &#x27;, &#x27; +  fragment.title + &#x27;, &#x27; + fragment.editor + &#x27;: &#x27; + fragment.fragment_name
    
    this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to DELETE this fragment?&#x27;, item_string).subscribe(result &#x3D;&gt; {
      if(result){
        this.api.delete_fragment({&#x27;id&#x27;:fragment.id}).subscribe(
          res &#x3D;&gt; this.utility.handle_error_message(res), err &#x3D;&gt; this.utility.handle_error_message(err)
        );
      }
    });
    // Now reset form and request the fragments again
    this.Reset_form();
    this.fragment_selected &#x3D; false;
    this.Request_fragments(this.selected_author, this.selected_book, this.selected_editor);
  }

  // public Request_automatic_fragment_linker(author, title){
    
  //   let item_string &#x3D; author + &#x27;, &#x27; +  title;
    
  //   let fragment &#x3D; new Fragment({});
  //   fragment.author &#x3D; author;
  //   fragment.title &#x3D; title;

  //   this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to LINK fragments from this text?&#x27;, item_string).subscribe(result &#x3D;&gt; {
  //     if(result){
  //       this.spinner_active &#x3D; true;
  //       this.api.automatic_fragment_linker(fragment).subscribe(
  //         res &#x3D;&gt; {
  //           this.utility.handle_error_message(res),
  //           this.spinner_active &#x3D; false;
  //         }, 
  //         err &#x3D;&gt; {
  //           this.utility.handle_error_message(err),
  //           this.spinner_active &#x3D; false;
  //         },
  //       );
  //     }
  //   });
  // }

  public add_bibliography_entry_to_fragment(bib_entry, fragment){
    console.log(&#x27;bib&#x27;, bib_entry._id)
    console.log(&#x27;frg&#x27;, fragment._id)

    console.log(this.fragmentForm.value)

  }

    //////////////////////////////////////////////
   // BIBLIOGRAPHY RELATED DASHBOARD FUNCTIONS //
  //////////////////////////////////////////////
  /** 
   * Filters the list of authors based on the user&#x27;s search input
   * @param value user input
   * @return bibliography authors that match the user&#x27;s input
   * @author Ycreak CptVickers
   */
     private filter_autocomplete_options(value: string): string[] {
      const filterValue &#x3D; value.toLowerCase();
      return this.bibliography_author_selection_form_options.filter(option &#x3D;&gt; option.toLowerCase().includes(filterValue));
    }
  
  /**
   * When changing the entry type for bibliographies, this function makes sure the type
   * is communicated with the bibliography form.
   * @author Ycreak, CptVickers
   * @param tab_change_event angular event that gives the bibliography type to be changed to.
   */  
  public on_bibliography_tab_change(tab_change_event: MatTabChangeEvent): void {
    this.UpdateForm(&#x27;bibliography_form&#x27;, &#x27;bib_entry_type&#x27;, tab_change_event.tab.textLabel.toLowerCase())
  }
  
  /**
   * When a bibliography entry is selected by the user, put all relevant data in the fields for easy
   * revision.
   * @param bib_entry with data for the selected entry
   * @author Ycreak, CptVickers
   */
  public handle_bib_entry_selection(bib_entry){

    console.log(bib_entry.bib_entry_type)
    // Jump automatically to the correct tab. FIXME: this works buggy
    if (bib_entry.bib_entry_type &#x3D;&#x3D; &#x27;book&#x27;) this.bibliography_form_selected_type.setValue(0);
    if (bib_entry.bib_entry_type &#x3D;&#x3D; &#x27;article&#x27;) this.bibliography_form_selected_type.setValue(1);

    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;_id&#x27;, bib_entry._id);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;author&#x27;, bib_entry.author);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;title&#x27;, bib_entry.title);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;year&#x27;, bib_entry.year);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;series&#x27;, bib_entry.series);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;number&#x27;, bib_entry.number);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;loction&#x27;, bib_entry.location);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;editon&#x27;, bib_entry.edition);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;journal&#x27;, bib_entry.journal);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;volume&#x27;, bib_entry.volume);
    this.UpdateForm(&#x27;bibliography_form&#x27;,&#x27;pages&#x27;, bib_entry.pages);


  }

  /**
   * Converts JSON into a angular list
   * @param authors_json json object from the server
   * @returns angular list with bibliography author names
   * @author Ycreak
   */
  public push_bibliography_authors_in_list(authors_json){
    let author_list: string[] &#x3D; [];
    
    for(let author in authors_json){
      author_list.push(authors_json[author].name);
    }
    return author_list
  }
  
  /**
   * Requests a list of authors from the bibliography database. Puts it in bibliography_author_selection_form_options for
   * use in the autocomplete module
   * @author Ycreak
   */
  public request_bibliography_authors(){
    this.api.get_bibliography_authors().subscribe(
      data &#x3D;&gt; {
        this.bibliography_author_selection_form_options &#x3D; this.push_bibliography_authors_in_list(data); //TODO: this need to be handled with a model
      },
      err &#x3D;&gt; this.utility.handle_error_message(err),
    );      
  }

  public request_bibliography_from_author(author){
    this.api.get_bibliography_from_author(author).subscribe(
      data &#x3D;&gt; {
        this.retrieved_author_bibliography &#x3D; data;
      });  
  }
  
  /**
   * This function request bibliography entries given its id. It then updates the fields
   * corresponding to this id for the Fragment Bibliography tab to use.
   * @param id identifier of the bibliography document
   * @author Ycreak, CptVickers
   */
  public request_bibliography_from_id(id){
    this.api.get_bibliography_from_id(id).subscribe(
      data &#x3D;&gt; {
        let temp; // simple object to access Python JSON (TODO: needs to be Angular model)
        temp &#x3D; data;       
        let linked_bib_entries &#x3D; this.fragmentForm.get(&#x27;linked_bib_entries&#x27;) as FormArray;
        // Find the entry with our id
        let index &#x3D; linked_bib_entries.value.findIndex(x &#x3D;&gt; x.bib_id &#x3D;&#x3D;&#x3D; id);
        // Add the data retrieved to the corresponding fields
        linked_bib_entries.at(index).get(&#x27;author&#x27;).setValue(temp.author);
        linked_bib_entries.at(index).get(&#x27;title&#x27;).setValue(temp.title);
        linked_bib_entries.at(index).get(&#x27;year&#x27;).setValue(temp.year);
      });  
  }

  public request_revise_bibliography_entry(bibliography){       
        
    let item_string &#x3D; bibliography.author + &#x27;, &#x27; +  bibliography.title

    this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to REVISE this bibliography entry?&#x27;, item_string).subscribe(result &#x3D;&gt; {
      if(result){
        this.api.revise_bibliography_entry(bibliography).subscribe(
          res &#x3D;&gt; {
            this.utility.handle_error_message(res),
            this.request_bibliography_authors();  // After a succesful response, retrieve the authors again.
          }, err &#x3D;&gt; this.utility.handle_error_message(err)
        );
      }
    });
    this.Reset_form();
  }

  public request_create_bibliography_entry(bibliography){

    let item_string &#x3D; bibliography.author + &#x27;, &#x27; +  bibliography.title

    this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to CREATE this bibliography entry?&#x27;, item_string).subscribe(result &#x3D;&gt; {
      if(result){
        this.api.create_bibliography_entry(bibliography).subscribe(
          res &#x3D;&gt; {
            this.utility.handle_error_message(res),
            this.request_bibliography_authors();  // After a succesful response, retrieve the authors again.
          }, err &#x3D;&gt; this.utility.handle_error_message(err)
        );
      }
    });
    this.Reset_form();
  }

  public request_delete_bibliography_entry(bibliography){
    let item_string &#x3D; bibliography.author + &#x27;, &#x27; +  bibliography.title
    
    this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to DELETE this bibliography entry?&#x27;, item_string).subscribe(result &#x3D;&gt; {
      if(result){
        this.api.delete_bibliography_entry({&#x27;_id&#x27;:bibliography._id}).subscribe(
          res &#x3D;&gt; {
            this.utility.handle_error_message(res),
            this.request_bibliography_authors();  // After a succesful response, retrieve the authors again.
          }, err &#x3D;&gt; this.utility.handle_error_message(err)        );
      }
    });
    this.Reset_form();
    this.bib_entry_selected &#x3D; false;
  }

    //////////////////////////////////////
   // USER RELATED DASHBOARD FUNCTIONS //
  //////////////////////////////////////
  public Request_change_password(form){
    if(form.password1 &#x3D;&#x3D; form.password2){
      this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to CHANGE your password&#x27;, this.authService.logged_user).subscribe(result &#x3D;&gt; {
        if(result){
          this.api.user_change_password({&#x27;username&#x27;:this.authService.logged_user,&#x27;new_password&#x27;:form.password1}).subscribe(
            res &#x3D;&gt; this.utility.handle_error_message(res), err &#x3D;&gt; this.utility.handle_error_message(err)
          );
        }
      });
    }
    else{
      this.utility.open_snackbar(&#x27;Passwords do not match.&#x27;);
    }
  }

  public Request_users(){
    this.api.get_users().subscribe(
      data &#x3D;&gt; {
        this.retrieved_users &#x3D; data;
        // Rebuild the table that displays the users
        this.dataSource &#x3D; new MatTableDataSource(this.retrieved_users);
        this.dataSource.paginator &#x3D; this.paginator;
        this.dataSource.sort &#x3D; this.sort;
      },
      err &#x3D;&gt; this.utility.handle_error_message(err),
    );      
  }

  public Request_create_user(new_user, new_password){

    if(new_user &#x3D;&#x3D; &#x27;&#x27; || new_password &#x3D;&#x3D; &#x27;&#x27;){
      this.utility.open_snackbar(&#x27;Please provide proper details&#x27;);
    }
    else{
      this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to CREATE this user?&#x27;, new_user).subscribe(result &#x3D;&gt; {
        if(result){
          this.api.create_user({&#x27;username&#x27;:new_user,&#x27;password&#x27;:new_password}).subscribe(
            res &#x3D;&gt; {
              this.utility.handle_error_message(res),
              this.Request_users();
            },
            err &#x3D;&gt; this.utility.handle_error_message(err)
          );
        }
      });
    }
  }

  public Request_change_role(user, role){
    let item_string &#x3D; user + &#x27;, &#x27; + role;
    this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to CHANGE the role of this user?&#x27;, item_string).subscribe(result &#x3D;&gt; {
      if(result){
        this.api.user_change_role({&#x27;username&#x27;:user,&#x27;new_role&#x27;:role}).subscribe(
          res &#x3D;&gt; {
            this.utility.handle_error_message(res),
            this.Request_users();
          },
          err &#x3D;&gt; this.utility.handle_error_message(err)
        );
      }
    });
  }

  public Request_delete_user(username){
    this.dialog.open_confirmation_dialog(&#x27;Are you sure you want to DELETE this user?&#x27;, username).subscribe(result &#x3D;&gt; {
      if(result){
        this.api.delete_user({&#x27;username&#x27;:username}).subscribe(
          res &#x3D;&gt; {
            this.utility.handle_error_message(res),
            this.Request_users();
            this.user_selected &#x3D; false;
          },
          err &#x3D;&gt; this.utility.handle_error_message(err)
        );
      }
    });
  }


}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'UserData.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>
       <script src="../js/libs/zepto.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
